---
title: "Project 2T - Working with Financial Data API"
author: "Cassio Monti & Smitali Patnaik"
date: "10/10/2022"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Goal and Specifications

The main goal of this vignette is to provide a set of functions that may assist in accessing specific information contained in the [Financial API](https://polygon.io/docs/stocks). These functions aim to provide data sets for further exploratory data analysis (EDA).   
  The companies selected for this analysis belong to two major groups, technology and real-state companies of the interest of the authors of this vignette. The companies related to the technology group are Apple, Microsoft, and Google. The companies related to real-state group are Weyerhaeuser and Rayonier, both are timberland investment groups.   
  Four functions were created querying data from 4 end points, or searching keywords, present in the the API. Further, three data sets were created and the EDA was executed for each of them separately. The EDA encompassed categorical and quantitative analyses, numerical and graphical, for each data according to their relevance to the [objective](#eda) of this analysis.   
  In order for this analysis to happen, some initial contact with the API and an access key are required.


# Required Packages

Some packages are necessary to run the code throughout this vignette. They are related to reading and parsing the API format, JSON format, to a more friendly and simplified view scheme, rectangular format, through the `jsonlite` package. The widely used `tidyverse` for data management, specifically using `dplyr`, and for nice correlation plots, `corrplot`.

```{r func_def}

# Getting relevant packages and calling the api
library(jsonlite)
library(tidyverse)
library(corrplot)

```


```{r key_setup, echo = FALSE}

key_id = c("foHUdTopBg22FTwv4b11YQsLuZXQkALG",
           "asWU9di2FThCr1ywIpgyNdqwXMf0fpj4","NrFY1wYudADe_0JmFFQAVxPFzuhritoB")

```

# API Querying Functions

There are four functions that are responsible for querying specific information from the mentioned financial API. The first function queries data from the *Aggregate endpoint*, which collects mainly price metrics for a single ticker over a pre-defined period of time. The second function, *Grouped endpoint*, queries prices related metrics for all tickers in a particular day. The function *Technical Indicator endpoint*, queries information corresponding to the moving average convergence/divergence and some other related metrics. The forth, and last function, *ticker endpoint*, queries the overall information about the tickers, for instance, official names, country of origin, type of market, and others.   
  As operating specificity, the *ticker* and *grouped* endpoints are working together to unify overall information about the tickers and price related metrics in a single data set. Additionally, *ticker* and *aggregate* endpoints are working together for the same purpose, but, in this case, returning a timely dependent data set.
  
  
  The function querying the *Technical Indicator endpoint* extracts information and?????????????????????? 

## Aggregate EndPoint

This function takes some modifiers defined in the financial API as the ticker ID `stocksTicker` (default is Apple's full name), the time frame arguments `from` and `to` (these arguments have default values corresponding to one year period from July 22nd 2021 to July 22nd 2022), the multiplier is the value associated to the `timespan` argument and they both together define the time frame in which the ticker will be obtained. For instance, if `timespan` is "minute" and multiplier is 1, then the returned data set will be aggregated every 1-minute interval across the time selected in `from` and `to` arguments.   
  This function takes all these arguments and pass them to the text format through the function `paste0()` associating each element of the URL required to form the query that goes to the API. The parts of this URL are the `base_endpoint` (provides the initial piece of the URL with the endpoint call), `last_code` (provides some other modifiers that are not going to be considered in this function), and `key` (provides the key id to access the API - since API has a limited free version, more keys are necessary to run a more complex query), besides the input arguments, which are all required. It is important to notice that this function, and the ones that use single input for companies, have the input `stocksTicker` as the full name of the listed company, for example, "Apple" should be provided instead of "AAPL". The same for "Microsoft", "Google", "Weyerhaeuser", and "Rayonier". Therefore, it was used the function `tolower()` to return the lower case of the company's name associated to the `switch()` function that assigns the specific company name to with the ticker symbol. The function is defined below.


```{r agg_endpoint}

# create the URL for aggregate endpoint:
# This function has some default values.
agg_endpoint = function(stocksTicker="Apple Inc.", from = "2021-07-22", to = "2022-07-22",mltplr=30, timespan="day", ky, ...){

  # converting the full name into the ticker symbol
  stocksTicker = switch(tolower(stocksTicker),
                        "apple" = "AAPL",
                        "google" = "GOOGL",
                        "microsoft" = "MSFT",
                        "weyerhaeuser" = "WY",
                        "rayonier" = "RYN",
                        stop("You are allowed to call only a limited number of companies: Apple, GOOGLE, Microsoft, Weyerhaeuser, Rayonier!"))
  
  # passing the components of the URL for the API:
  # base + endpoint 1
  base_endpoint = "https://api.polygon.io/v2/aggs/"
  
  # last part of the URL defining some defaults
  last_code = "?adjusted=true&sort=asc&limit=5000"
  
  # key for accessing API
  key = paste0("&apiKey=", key_id[ky])
  
  # converting the multiplier to character
  mltplr = as.character(mltplr)
  
  # creating the URL call
  call = paste0(base_endpoint,"ticker/",stocksTicker,"/range/",mltplr,"/",
                timespan,"/",from,"/",to,last_code,key)
  
  # assigning the call to an object
  p = fromJSON(call)

  # getting results from the object
  tb = p$results
  tckr = p$ticker
  
  # working with the dates
  d1 = as.Date(from) # transforms initial date from char to date format
  d2 = as.Date(to) # transforms last date from char to date format
  d = seq(d1,d2, by ="month") # sequence by month
  
  # combining the final object with ticker name, date, and metrics
  out = tibble(tckr,d,tb)
  
  # returning the final tibble object
  return(out)
  
}

```

## Grouped Daily EndPoint

For merging with the ticker endpoint data set and go to the EDA.


```{r group_endpoint}

# creates the URL for group endpoint:
# This function has some default values.
grouped_endpoint = function(date= "2022-07-14", adjusted = "true", otc = "true", ky, ...){
  
  # this code sets to lower case the arguments adjusted and otc.
  adjusted = tolower(adjusted)
  otc = tolower(otc)
  
  # base + endpoint 1
  base="https://api.polygon.io/v2/aggs/grouped/locale/us/market/stocks/"
  
  # key for accessing API
  key = paste0("&apiKey=", key_id[ky])
  
  # creating the URL call
  call = paste0(base,date,"?adjusted=",adjusted,"&include_otc=",otc,key)
  
  # assigning the call to an object
  p = fromJSON(call)

  # transforming the data frame into tibble for better printing
  out = tibble(p$results)
  
  return(out)
}

```


## Technical Indicators EndPoint


```{r macd_endpoint}


macd_endpoint = function(stocksTicker="Apple", date = "2022-07-22", ky, ..) {

    stocksTicker = switch(tolower(stocksTicker),
                        "apple" = "AAPL",
                        "google" = "GOOGL",
                        "microsoft" = "MSFT",
                        "weyerhaeuser" = "WY",
                        "rayonier" = "RYN",
                         stop("You are allowed to call only a limited number of companies: Apple, GOOGLE, Microsoft, Weyerhaeuser, Rayonier!"))

  # base + endpoint 1
  base="https://api.polygon.io/v1/indicators/macd/"
  
  # key for accessing API
  key = paste0("&apiKey=", key_id[ky])
  
  # creating the URL call
  call = paste0(base,stocksTicker,"?timestamp=",date,"&timespan=hour&adjusted=true&short_window=12&long_window=26&signal_window=9&series_type=close&order=desc",key)
  
  
  # assigning the call to an object
  p = fromJSON(call)
  outd = tibble(p$results$values)
  
  return(outd)
}

```

## Ticker EndPoint

This function aims to call tickers from common stock mainly and other markets as well as crypto currencies for further analysis of both.

```{r ticker_endpoint}

# tickers endpoint= get ticker names
# create the URL for the ticker endpoint - two calls: i) ticker names; and
# ii) otc names
ticker_endpoint = function(type = NULL, market = "stocks", limit = 1000, ticker = NULL, ky, ...){
  

  if(limit > 1000){
    limit = 1000
    message("Warning: the max limit is 1000 for free access!")
  }

  last_code = "&active=true&sort=locale&order=asc&limit="
  
  key = paste0("&apiKey=", key_id[ky])

    
  if(!is.null(ticker)){
    
          ticker = switch(tolower(ticker),
                        "apple" = "AAPL",
                        "google" = "GOOGL",
                        "microsoft" = "MSFT",
                        "weyerhaeuser" = "WY",
                        "rayonier" = "RYN",
                         stop("You are allowed to call only a limited number of companies: Apple, GOOGLE, Microsoft, Weyerhaeuser, Rayonier!"))

    
      base_endpoint = "https://api.polygon.io/v3/reference/tickers?ticker="
      
      call = paste0(base_endpoint,ticker)

  }else{
    
      base_endpoint = "https://api.polygon.io/v3/reference/tickers?market="
      
      market = tolower(market)
      
      call = paste0(base_endpoint,market)

  }
  
  if(!is.null(type)){
    
    type = switch(tolower(type),
               "common stock" = "CS",
               "investment fund" = "FUND",
               "exchanged-traded fund" = "ETF",
               "standard & poors" = "SP",
                stop("This is not one of the allowed options!"))
    
    call = paste0(call, "&type=", tp, last_code, limit, key)
    
  }else{
    
    call = paste0(call, last_code, limit, key)
    
  }

  p = fromJSON(call)
  
  return(p$results)

}

```

## Wrapper Function

This function takes information from the previous two functions and combine them when it is possible.

```{r wrapper}

# ticker vector to call the API
# tickers = c("AAPL","GOOGL", "MSFT","WY","RYN")
tickers = c("Apple", "Google", "Microsoft", "Weyerhaeuser", "Rayonier")

# calling the full name of the companies
CompanyName = sapply(tickers, function(x){
  return(ticker_endpoint(ticker = x, ky = 1)$name)
})

# call multiple tickers from agg_endpoint and return sa df
agg_data = lapply(tickers, agg_endpoint, ky = 1)

Combining_calls = function(tickerID, ...){
  
  # grouping quantitative EDA data - time analysis
  time_df = lapply(1:length(agg_data), function(x){
    
    return(cbind(Company_Name = CompanyName[x], agg_data[[x]]))
  })
  
  time_df <- do.call("rbind", time_df)
  
  time_df = as_tibble(time_df)
  
  
  # grouping categorical EDA data
  tout = ticker_endpoint(market = "stocks", limit = 1000, ky=2)

  tout2 = ticker_endpoint(market = "otc", limit = 1000, ky=2)
  
  gout = grouped_endpoint(otc = "true",ky=2)

  df1 = inner_join(tout2, gout, by = c("ticker" = "T"))

  df11= df1 %>%
  select(ticker, name, market, type, composite_figi,share_class_figi, v:n)

  df2 = inner_join(tout, gout, by = c("ticker" = "T"))

  df22 = df2 %>%
    select(ticker, name, market, type,composite_figi,share_class_figi, v:n)

  df = rbind(df11, df22)

  df = df %>% drop_na()
  
  #### macd data
  
  macd_data = lapply(tickers, macd_endpoint, ky = 3)
  macd_df = lapply(1:length(macd_data), function(x){
    return(cbind(Company_Name = CompanyName[x], macd_data[[x]]))
  
    })
  
  macd_df <- do.call("rbind", macd_df)
  macd_df = as_tibble(macd_df)
  return(list(df = df, time_df = time_df,macd_df=macd_df))
  
}

out = Combining_calls(tickerID = tickers)
df = out$df
time_df = out$time_df

macd_df=out$macd_df
macd_df

```


# EDA

The main objective of the EDA presented herein is to analyze data sets and extract meaningful information to the user if the reader of this vignette was a beginner in investments seeking for starting point upon which market and industry type are more interesting in terms of risk and return.

## For several tickers

### Plots for raw data

```{r}

# for categorical and numerical EDA
df

table(df$market)

table(df$type)

table(df$market, df$type)

# type vs market
g = ggplot(df, aes(x = market))
g + geom_bar(aes(fill = type), position = "dodge")

```


### Plots for modified Data - part 1

```{r}
# quantitative vs market & type
# group by type and market and average
df_price = df %>% 
  group_by(market, type) %>%
  summarise(avg_price = mean(c), price_range = (h - l))

h = ggplot(df_price, aes(x = avg_price))

# histograms by market type
h + geom_density(adjust = 0.5, alpha = 0.5, aes(fill = market))
h + geom_density(adjust = 0.5, alpha = 0.5, aes(fill = type))

# histogram + density plot for closed price by market type
h + geom_histogram(aes(fill = market, y = ..density..), position = "dodge") + 
  geom_density(adjust = 0.5, alpha = 0.5, aes(fill = market))

h + geom_histogram(aes(fill = type, y = ..density..), position = "dodge") + 
  geom_density(adjust = 0.5, alpha = 0.5, aes(fill = type))


# boxplot by market and typer for avg price
h + geom_boxplot(aes(y = market)) + coord_flip()

h + geom_boxplot(aes(y = type)) + coord_flip()

```



### Plots for modified Data - part 2

```{r}

# Empirical CDF by market type - price 50% above price avg up to max price
df_filter_price = df %>%
  filter(c > 1.5*mean(df$c) & c < max(c))

h1 = ggplot(df_filter_price, aes(x = c))
h1 + stat_ecdf(geom = "step", aes(color = market)) + ylab("ECDF")
h1 + stat_ecdf(geom = "step", aes(color = type)) + ylab("ECDF")

# histograms by market type
h1 + geom_density(adjust = 0.5, alpha = 0.5, aes(fill = market))
h1 + geom_density(adjust = 0.5, alpha = 0.5, aes(fill = type))

# histogram + density plot for closed price by market type
h1 + geom_histogram(aes(fill = market, y = ..density..), position = "dodge") + 
  geom_density(adjust = 0.5, alpha = 0.5, aes(fill = market))

h1 + geom_histogram(aes(fill = type, y = ..density..), position = "dodge") + 
  geom_density(adjust = 0.5, alpha = 0.5, aes(fill = type))

# scatter plot
h1 + geom_point(aes(y = h)) + facet_wrap(~market)
h1 + geom_point(aes(y = h)) + facet_wrap(~type)

```

## For time data

```{r}

# for either categorical, numerical, and timely EDa
g <- ggplot(time_df, aes(y = c, color = tckr))
g + geom_line(aes(x = d, color = tckr),lwd = 1.5)

# scatter plot + curve
g + geom_point(aes(x = d)) + geom_smooth(method = "gam", aes(x = d))


```

###EXPLORATORY DATA ANALYSIS.

#### Data Visibility

Before proceeding to the detailed EDA of the data sets taken from the APIs, some minor changes have been made to the data frame df. 
The columns have been renamed as

c - Closing_price
h - Highest_price 
l - Lowest_price 
n - Transactions
o - Open_price 
t - Unix_time
v- Trading_volume
vW- Volume_wt_avg_price

Also,the unix time format has been changed to date format.

Typical price is used to determine volume weighted price. Typical price has been derived as sum of the closing price , highest price and lower price.  

```{r}


df<-df %>% 
  rename(
    Closing_price=c,
    Highest_price=h,
    Lowest_price=l, 
    Transactions=n,
    Open_price=o, 
    Unix_time=t,
    Trading_volume=v,
    Volume_wt_avg_price=vw
   )

df<- df %>% mutate(Date= as.POSIXct(df$Unix_time/1000,origin = "1970-01-01"))
df$Date<-as.Date(df$Date)

df<- df %>% mutate(Sum_Typical_price= (Closing_price+Highest_price+Lowest_price)/3)
df

``` 

##### Contingency table - I with Bar plots.

The First contingency table states count of pooled investment based on the market for the given ticker data set. And also graphs it in a bar plot. This shows that there were maximum tickers for the stock market for CS and maximum for OTC for OS. It was noted that tickers/companies  with ADRC, CS,OS and UNIT investments had both OTC markets. Rest of tickers had just stock market based investments. 

```{r fig.width=15,fig.height=5}
tab_cate1<-table(df$type,df$market)
tab_cate1

g <- ggplot(data = df, aes(fill=as.factor(market),x=type))
g + geom_bar( stat = "count",position="dodge")+ labs(x = "Type of Investment", y = "Count",title=" Count of Investments based on Market")+scale_fill_discrete(name = "Market ")
```

##### Contingency table - II 

The other contingency table calculates mean of all the quantitative parameters based on two groups- market and type . This uses group_by to group categorical variables and mean of all the quantitative variables are calculated for the subsequent groups. 
 
The Trading volume was maximum for OTC/CS type tickers followed by Stocks/ETV. The mean volume weighted price is maximum for tickers with maximum price for the given price variables. 

```{r}
df_summary<-df%>% select(- c("ticker","name","composite_figi","share_class_figi","Date"))
tab_cate2<-df_summary%>% group_by(market,type) %>%  summarise_all(mean)
tab_cate2

```

##### Scatter Plot

The chart below shows the correlation between the open price and the volume weighted average price. This chart chart simply establishes the fact that vW or volume weighted price is derived from the closing price, highest and lowest price. And this is bound to be linear relation for every ticker. The correlation calculated was 0.999907.

```{r fig.width=5,fig.height=5}
correlation<-cor(df$Volume_wt_avg_price,df$Open_price)
correlation

g <- ggplot(data =df, aes(x=Volume_wt_avg_price,y=Closing_price))
g + geom_point(color="red") + geom_smooth(method=lm, fullrange=FALSE)+labs(x= "Closing Price", y= "Volume Weighted Price" ,title ="Closing Price  vs Weighted Average Price")

```

#### Box Plot for Highest Price based on Investment type

For the given day the Range of Highest price based on Investment type are summarized through the bar graphs. The CS investment type shows an outlier of ~$1100 . The mean is maximum for ETV type.

```{r fig.width=15,fig.height=5}

g <- ggplot(data = df, aes(x=type,y=Highest_price,fill=type))
g + geom_boxplot()+ stat_summary(fun = mean,
lwd = 0.05,aes(group = type))+labs(x="Type" ,y= "Highest price",title ="Boxplot for Spred of Highest Price grouped by Investment Type ")

```

The histogram is for looking the frequency of the transactions for each group of market for the given time period. The total  count of count of transactions less < 1000 are maximum for both market types. And hence, the plot is skewed to the left. 

``` {r fig.width=15,fig.height=5}

ggplot(df,aes(x=Transactions,fill=market)) + geom_histogram( position="dodge")+labs(x="Transactions" ,y= "Count ",title ="Histogram of Number of transactions grouped by Market ")

```

Similar , excercise has been implemented for this dataframe as well. Where the columns have been renamed to easiliy identify the variables. 

```{r}

time_df<-time_df %>% 
  rename(
    Closing_price=c,
    Highest_price=h,
    Lowest_price=l, 
    Transactions=n,
    Open_price=o, 
    Unix_time=t,
    Trading_volume=v,
    Volume_wt_avg_price=vw,
    Date=d
   )

time_df
```

#### Summary Table

This table summarizes the means of the pricing, transactions and volume for the select technology and timberland companies. There is no relation b/w two industries but this data is pretty obvious that the Tech giants price more and have bigger penetration in the trading business. Majority of these companies have world-wide presence compare to timberland companies. These tech giants have net worth approx in billions and having a price in the range of $ 100+ for given time period is not surprising. Apple is the company having highest trading volume and Microsoft had the highest average prices for the given time range. 

``` {r}
time_df_summary<- select(time_df, -c( "tckr","Date"))
time_df_summary<-time_df_summary %>% group_by(Company_Name) %>% summarize_all(mean)
time_df_summary

```

##### Bar Plot with Facet Wrap.

The Mean of transactions grouped by Industry type has been shown below as we have 3 technology companies and 2 timberland companies selected for the subplots. This shows again transaction wise Technology companies have a higher trend. In the month of Jan 2022 Technology companies had maximum transactions with timberland showing higher numbers in the month of April.

``` {r fig.width=15,fig.height=5}
time_df2<-time_df%>% mutate(Industry='Technology')
time_df2$Industry <-ifelse(time_df2$tckr=="WY" | time_df2$tckr=="WY" , "Finance", "Technology")

ggplot(time_df2, aes(x=as.factor(Date), y=Transactions,fill=Industry))+ geom_bar( stat = "summary", fun.y = "mean")+ facet_wrap(~Industry,  nrow=2 )+guides(x = guide_axis(angle = 90))+ labs(x= "Transactions", y= "Date",title=" Mean Transactions for the time period grouped by Industry type")+scale_fill_discrete(name = "Industry Type ")
```

#### Line Plots

The Volume weighted price trend has been captured in the below plot for each company. Apple as expected showing highest trends line. It saw lowest numbers in the Jul 2021 and again in Jul 2022. It is interesting to note all technology companies saw peaks in the month of Nov 2021, Jan 2022 and Apr 2022

``` {r fig.width=15,fig.height=5}
ggplot(time_df2, aes(x = Date, y = Transactions, colour =Company_Name, group = Company_Name)) +geom_line() + geom_point()+labs(x= "Date", y= "Volume Weighted Average Price",title=" Volume weighted price for the time range grouped by Companies")

```

#### Scatter Plot. 

The Volume of trades vs transactions can be looked into to find a relation. We see that for every company the relation is closely linear. So as the Transactions increase we also see growth in trading volume.

``` {r fig.width=15,fig.height=5}
g <- ggplot(data =time_df2, aes(x=Transactions,y=Trading_volume,colour=Company_Name))
g + geom_point() +labs(x= "Trading Volume", y= "Transactions" ,title ="Trading Volume vs Transactions grouped by Companies")

```

####TEST API

A bullish crossover occurs when the MACD turns up and crosses above the signal line. 
A bearish crossover occurs when the MACD turns down and crosses below the signal line.

The relation between two helps determining if stock can be bought or not.

```{r fig.width=10,fig.height=5}

macd_df

g <- ggplot(data =macd_df, aes(x=signal,y=value))
g + geom_point(color="red") + facet_wrap(~Company_Name)+guides(x = guide_axis(angle = 90))+ labs(x= "Signal", y= "Value",title=" Signal vs Value")+scale_fill_discrete(name = "Company Name ")

```


